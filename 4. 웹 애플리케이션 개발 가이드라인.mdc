통합 웹 애플리케이션 개발 가이드라인 v1.1
서론: 가이드라인의 목적
본 문서는 정적 HTML 디자인을 기반으로, 확장 가능하고 유지보수가 용이한 동적 웹 애플리케이션을 구축하는 표준 프로세스와 기술 명세를 통합하여 제공합니다. 데이터 수집부터 관리, 그리고 최종 사용자에게 보여주는 프론트엔드 구현까지의 전 과정을 다루며, 프로젝트의 예측 가능성과 품질을 높이는 것을 목표로 합니다.

Part 1: 개발 프로세스 및 프로젝트 관리
1. 개발 관리 규칙 (Project Management)
모든 개발 작업은 예측 가능하고 투명하게 관리되어야 합니다.

산출물 관리: 모든 개발 산출물은 사전에 정의된 디렉토리에 저장하며, 완료 시 확인 가능한 URL을 공유해야 합니다.

#**체크 파일 관리: 모든 개발 작업은 다음 두 가지 체크 파일을 필수로 생성하고 관리합니다.**
** DEVELOPMENT_STATUS.md: 현재 개발 상태, 완료 항목, 진행 및 다음 작업 목록.**
** DEVELOPMENT_TASKS.md: 전체 태스크 목록, 단계별 진행률, 개발 목표. **

** 칸반 보드 활용: 작업 흐름 시각화를 위해 칸반 보드(To Do, In Progress, Done) 사용을 강력히 권장합니다. 이는 팀 전체가 프로젝트 진행 상황을 직관적으로 파악하고 병목 현상을 조기에 발견하는 데 도움을 줍니다.**

2. 개발 단계별 수행 절차
1단계: 요구사항 분석 및 작업 분할 (Analysis & Breakdown)
정적 HTML 디자인에서 동적 기능 요구사항을 정밀하게 추출하고 개발 가능한 최소 단위로 분할합니다.

HTML 파일 목록 검토: 프로젝트의 모든 HTML 파일 목록을 작성하고 각 페이지의 목적을 파악합니다.

링크 유형별 기능 분석: <a>, <button> 태그를 중심으로 기능 요구사항을 세 가지 유형으로 분석합니다.

정적 링크: 다른 HTML 페이지로 이동 (href="about.html").

동적 링크: 데이터에 따라 경로가 동적으로 생성 (href="products/123"). 이는 [Part 2] 6.4. 조회(읽기) 기능과 직접 연관됩니다.

기능 링크: 페이지 이동 외의 동작 수행 (onclick="openModal()"). 이는 [Part 2] 6.1. 등록, 6.2. 수정, 6.3. 삭제 등 특정 서버 기능 호출과 연관됩니다.

엔티티 및 속성 정의: 요구사항을 기반으로 필요한 데이터 엔티티(예: Users, Posts)와 속성(예: title, content)을 초안 수준에서 정의합니다. 상세 설계는 [Part 2] 5. 데이터 설계를 따릅니다.

2단계: 작업 우선순위 결정 (Prioritization)
분할된 작업을 효율적인 순서로 배열하여 개발 로드맵을 수립합니다.

의존성 기반 정렬: 선행되어야 할 작업(예: 로그인)을 먼저 개발합니다.

공통 컴포넌트 우선: 여러 페이지에서 재사용되는 요소(헤더, 푸터, 레이아웃)를 먼저 개발합니다.

핵심 기능 우선: 프로젝트의 존재 이유가 되는 핵심 기능(예: 상품 조회)부터 개발합니다.

3단계: 백엔드 및 DB 설계 (Backend & DB Design)
분석된 요구사항을 바탕으로 **[Part 2]**의 상세 기술 명세에 따라 백엔드와 데이터베이스를 설계합니다.

4단계: 신규 페이지 추가 및 확장
새로운 HTML 페이지가 추가될 경우, 아래 절차를 통해 코드 중복 없이 효율적으로 확장합니다.

신규 요구사항 분석: 추가된 HTML에 대해 1단계를 동일하게 수행합니다.

기존 기능/컴포넌트 대조: 분석된 요구사항을 기존 개발 완료 목록과 비교하여 재사용 가능성을 확인합니다.

순수 신규 작업만 추가: 재사용이 불가능한 순수 신규 작업만 식별하여 백로그에 추가합니다. 이는 DRY(Don't Repeat Yourself) 원칙을 실현하는 핵심 전략입니다. 

Part 2: 기술 명세 및 구현 가이드
3. 데이터 구조 정의 (HTML 콘텐츠 분석)
HTML 문서 내의 비정형 데이터를 구조화된 정보로 변환하는 규칙과 절차를 정의합니다.

3.1. 분석 전략: HTML5 시맨틱 태그, 구조적 태그, 메타데이터를 종합적으로 활용합니다.

3.2. 데이터 추출 대상 필드: 제목, 내용, 작성자 등 모든 데이터 소스에 공통적으로 적용될 핵심 필드를 사전 정의합니다.

3.3. 매핑 규칙 및 추출 기술: CSS 선택자, XPath 등을 활용하여 필드를 추출하는 규칙을 외부 설정 파일(YAML 등)로 관리합니다.

폴백(Fallback) 설계: 웹사이트 구조 변경에 유연하게 대응하기 위해 필드별로 여러 추출 규칙을 우선순위에 따라 정의합니다.

3.4. 추출 규칙 자동 생성: 관리자가 샘플 HTML을 업로드하면 시스템이 자동으로 추출 규칙 초안을 생성하는 기능을 구현합니다.

4. 자동 수집 및 등록 시스템
HTML 파일 업로드부터 데이터베이스 등록까지의 자동화 프로세스와 예외 처리를 정의합니다.

4.1. 수집 흐름: HTML 업로드 → 규칙 로드 → 데이터 추출 → 유효성 검사 → 관리자 검토 → DB 저장의 파이프라인을 따릅니다.

4.2. 실패 처리: 특정 필드 추출 실패 시, 상세 내용을 포함한 구조화된 로그를 기록하고 관리자에게 즉시 피드백하여 규칙 수정 등의 후속 조치를 유도합니다.

4.3. 추출 규칙의 유연한 관리:

규칙 외부화: 추출 규칙을 DB나 별도 파일로 관리하여, 시스템 재배포 없이 규칙을 수정할 수 있게 합니다.

UI 기반 편집기: 관리자가 웹 UI를 통해 규칙을 직접 수정하고, 샘플 HTML로 즉시 테스트할 수 있는 기능을 제공합니다.

버전 관리: 규칙 변경 이력을 모두 버전으로 관리하여, 문제 발생 시 특정 버전으로 쉽게 롤백할 수 있도록 합니다.

5. 데이터 설계 (DB Schema)
다양한 소스에서 수집된 데이터를 일관성 있게 저장하고, 검색 성능과 확장성을 모두 만족시키는 데이터베이스를 설계합니다.

5.1. 핵심 테이블(contents): 모든 콘텐츠의 공통 정보를 관리하는 메인 테이블을 정의합니다.

id, source_id, uid, title, content_text, content_html, source_url, author, status, published_at, extra_data 등의 필드를 포함합니다.

5.2. 확장성을 위한 유연한 필드 구조 (extra_data):

쇼핑몰의 '가격', 채용 사이트의 '요구 경력' 등 소스별 고유 정보를 저장하기 위해 JSONB 타입의 extra_data 필드를 활용합니다.

이는 DB 스키마 변경(ALTER TABLE) 없이 새로운 유형의 데이터를 유연하게 포용할 수 있게 해주는 핵심 설계입니다.

5.3. 분류 체계 (태그 및 카테고리):

콘텐츠 분류를 위해 categories, tags 테이블과 이들을 연결하는 매핑 테이블(content_tags)을 별도로 설계하여 다대다(N:M) 관계를 관리합니다. 이는 데이터의 일관성을 유지하고 효율적인 쿼리를 가능하게 합니다.

6. 관리자 기능 및 UI/UX (Admin CRUD & Interface)
수집된 데이터를 관리하기 위한 CRUD(생성, 조회, 수정, 삭제) 기능과 사용자 인터페이스를 정의합니다.

6.1. 등록(Create): HTML 파일 업로드를 통한 자동 추출과 수동 입력/수정을 결합한 하이브리드 방식을 제공합니다.

6.2. 수정(Update): WYSIWYG 에디터를 제공하여 content_html을 직관적으로 편집할 수 있도록 지원합니다.

6.3. 삭제(Delete): 데이터를 물리적으로 삭제하는 대신 status 필드를 'deleted'로 변경하는 소프트 삭제(Soft Delete) 방식을 채택하여, 데이터 복구 및 감사 추적이 가능하도록 합니다.

6.4. 조회(Read): 제목, 내용, 날짜, 태그, 상태 등 다양한 조건으로 데이터를 필터링하고 정렬할 수 있는 강력한 검색 기능을 제공합니다.

6.5. UI/UX: 마스터-디테일 레이아웃, 확인/피드백 메시지, 로딩 상태 표시, 변경 이력 추적 등 사용자 경험을 향상시키는 요소를 적극 도입합니다.

7. 프론트엔드 개발 및 API 연동 (Updated Section)
디자인 시안을 바탕으로 시맨틱하고 접근성 높은 인터랙티브 웹 페이지를 개발하기 위한 원칙과 표준, 그리고 API 연동 방식을 정의합니다. 

7.1. 개발 원칙 및 품질

구현 원칙: 비즈니스 로직 구현을 위해 테스트를 먼저 작성하는 **TDD(Test-Driven Development)**를 지향하며, 모든 코드는 SOLID 원칙과 클린 코드 원칙을 준수하여 설계합니다. 


품질 원칙: 코드 가독성을 최우선으로 고려하며, DRY(Don't Repeat Yourself) 원칙에 따라 중복을 제거하고 컴포넌트 재사용성을 높입니다. 


테스트 자동화: 단위 테스트(Unit Test) 커버리지 80% 이상을 목표로 합니다. 

7.2. 구현 표준

구조화된 마크업: 시맨틱 HTML 태그를 사용하여 콘텐츠의 의미와 구조를 명확히 표현합니다. 


스타일링: 정의된 디자인 시스템을 기반으로 CSS를 작성하여 모든 페이지와 컴포넌트의 일관성을 유지합니다. 


인터랙션: JavaScript를 사용하여 사용자의 행동에 반응하는 동적인 인터랙션을 구현합니다. 


웹 표준 준수: 검색엔진 최적화(SEO)를 위한 메타, OG 태그를 적용하고, 웹 접근성 표준(ARIA 속성 등)을 준수하여 모든 사용자가 서비스를 원활하게 이용할 수 있도록 합니다. 

7.3. API 설계 및 연동
API 설계 원칙 (RESTful API):

자원(Resource) 중심: 모든 API는 명사 중심의 자원 경로(예: /contents, /tags)로 표현합니다.

행위(Verb) 중심: 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현합니다.

표준 응답 구조: 성공/실패 여부, 데이터, 메시지를 포함하는 일관된 JSON 응답 구조(예: JSend)를 사용합니다.

주요 API 엔드포인트 예시:

GET /api/contents: 콘텐츠 목록 조회 (검색, 필터링, 정렬, 페이지네이션 지원)

GET /api/contents/{id}: 특정 콘텐츠 상세 조회

7.4. 협업 및 제안
수동적인 구현을 넘어 프로젝트 품질 향상을 위해 적극적으로 기여합니다. 개발 과정에서 발견된 디자인 시스템, 정보구조(IA)의 개선점이나 기술적으로 더 나은 구현 방식을 발견할 경우, 

구체적인 대안과 적용 범위를 역으로 제안합니다. 

7.5. 최종 산출물

소스 코드 구조: 아래와 같은 기본 구조로 소스 코드를 제공합니다. 


/index.html 


/css/style.css 


/js/main.js 


문서화: 다이어그램 등 복잡한 로직이나 구조는 Mermaid 또는 SVG를 사용하여 명확하게 문서화합니다. 

8. 보안 및 접근 제어 (Security & Access)
데이터와 시스템을 내외부 위협으로부터 보호하기 위한 보안 정책을 정의합니다.

8.1. 다계층 보안 접근: 네트워크, 애플리케이션, 데이터 각 계층에서 독립적인 보안 통제를 적용하는 심층 방어(Defense in Depth) 전략을 채택합니다.

8.2. 주요 보안 위협 대응:

SQL Injection: 모든 DB 쿼리는 **Prepared Statement(매개변수화 쿼리)**를 사용합니다.

XSS (Cross-Site Scripting): 사용자 입력 값 출력 시 이스케이프 처리를 하고, HTML 저장 시에는 허용된 태그/속성 목록(Whitelist) 기반으로 HTML Sanitization을 수행합니다.

계정 보안: 비밀번호는 Bcrypt 등 적응형 해시 함수로 저장하고, 주요 관리자에게는 2단계 인증(MFA) 적용을 의무화합니다.

8.3. 역할 기반 접근 제어 (RBAC):

최고 관리자, 데이터 편집자, 읽기 전용 사용자 등 역할별로 시스템 기능 접근 권한을 차등 부여합니다.

모든 API 요청 시, 사용자의 역할이 해당 작업을 수행할 권한이 있는지 반드시 검증합니다.

9. 로깅 및 감사 추적 (Logging & Auditing)
시스템의 신뢰성과 안정성을 확보하고, 문제 발생 시 원인을 신속하게 파악하기 위한 로깅 정책을 정의합니다.

9.1. 데이터 변경 감사 로그 (content_audit_logs): "누가, 언제, 어떤 데이터를, 어떻게 변경했는지"를 추적하기 위해 모든 CUD(생성, 수정, 삭제) 작업에 대한 로그를 별도 테이블에 기록합니다.

변경 전(from) 값과 변경 후(to) 값을 JSONB 형태로 저장하여 변경 내용을 정밀하게 추적합니다.

9.2. 시스템 로그 (애플리케이션 로그):

모든 시스템 이벤트 로그는 단순 텍스트가 아닌 구조화된 JSON 형식으로 기록합니다.

이는 로그 관리 시스템(ELK, Datadog 등)에서 특정 조건(예: user_id)으로 로그를 효율적으로 검색, 필터링, 분석할 수 있게 하여 문제 해결 시간을 획기적으로 단축시킵니다.